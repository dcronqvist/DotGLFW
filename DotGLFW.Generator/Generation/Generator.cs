using System;
using System.Linq;
using System.Text;
using HtmlAgilityPack;

namespace DotGLFW.Generator;

public partial class Generator : IGenerator
{
  private readonly IModelProvider _modelProvider;
  private readonly ISourceWriter _sourceWriter;
  private readonly string _glfwDocsBaseUrl;
  private readonly string _licenseHeader;

  private const string NativeGLFWClassName = "NativeGlfw";

  public Generator(
    IModelProvider modelProvider,
    ISourceWriter sourceWriter,
    string glfwDocsBaseUrl,
    string licenseHeader)
  {
    _modelProvider = modelProvider;
    _sourceWriter = sourceWriter;
    _glfwDocsBaseUrl = glfwDocsBaseUrl;
    _licenseHeader = licenseHeader;
  }

  public void Generate()
  {
    var api = _modelProvider.GetAPI();
    GenerateNativeBinding(api);
    GenerateWrapperStructs(api);
    GenerateEnums(api);
  }

  private void WriteFileHeader(StringBuilder stringBuilder)
  {
    var licenseLines = _licenseHeader.Split(Environment.NewLine);
    foreach (var line in licenseLines)
      stringBuilder.AppendLine($"//  {line}");
    stringBuilder.AppendLine();
    stringBuilder.AppendLine("// This file was generated by DotGLFW.Generator. Do not modify it manually.");
    stringBuilder.AppendLine();
  }

  private string SanitizeIdentifierForCSharp(string identifier)
  {
    string[] reservedKeywords = [
      "abstract", "as", "base", "bool", "break",
      "byte", "case", "catch", "char", "checked",
      "class", "const", "continue", "decimal", "default",
      "delegate", "do", "double", "else", "enum",
      "event", "explicit", "extern", "false", "finally",
      "fixed", "float", "for", "foreach", "goto", "if",
      "implicit", "in", "int", "interface", "internal",
      "is", "lock", "long", "namespace", "new", "null",
      "object", "operator", "out", "override", "params",
      "private", "protected", "public", "readonly",
      "ref", "return", "sbyte", "sealed", "short",
      "sizeof", "stackalloc", "static", "string",
      "struct", "switch", "this", "throw", "true",
      "try", "typeof", "uint", "ulong", "unchecked",
      "unsafe", "ushort", "using", "virtual", "void",
      "volatile", "while"
    ];

    if (reservedKeywords.Contains(identifier))
      return "@" + identifier;

    return identifier;
  }

  private string ParseFunctionDocsIntoXMLDocs(HtmlNode node, ParsedAPI api, Func<string, string> getCref)
  {
    if (node is null)
      return string.Empty;

    var doChildren = (HtmlNode parent) =>
    {
      StringBuilder stringBuilder = new();

      var firstChild = parent.FirstChild;
      while (firstChild != null)
      {
        stringBuilder.Append(ParseFunctionDocsIntoXMLDocs(firstChild, api, getCref));
        firstChild = firstChild.NextSibling;
      }
      return stringBuilder.ToString();
    };

    if (node.Name == "p")
    {
      return $"<para>{doChildren(node)}</para>";
    }
    else if (node.Name == "#text")
    {
      var text = node.InnerText.FixNewlines();
      return text;
    }
    else if (node.Name == "a")
    {
      var innerText = node.InnerText.FixNewlines().Replace(",", "");
      if (IsIdentifierPartOfAPI(innerText, api))
      {
        var cref = getCref(innerText);
        return $"<see cref=\"{cref}\" />";
      }

      var docsBaseUrl = _glfwDocsBaseUrl;

      return $"<see href=\"{docsBaseUrl}{node.GetAttributeValue("href", "")}\">{innerText}</see>";
    }
    else if (node.Name == "table")
    {
      return string.Empty;
    }
    else if (node.Name == "dl")
    {
      var dd = node.Descendants("dd").FirstOrDefault();
      var ddInner = doChildren(dd);
      if (string.IsNullOrWhiteSpace(ddInner))
        return string.Empty;

      return $"<para>{doChildren(node)}</para>";
    }
    else if (node.Name == "dt")
    {
      return $"<b>{doChildren(node)}</b>";
    }
    else if (node.Name == "dd")
    {
      return $"<para>{doChildren(node)}</para>";
    }
    else if (node.Name == "div")
    {
      if (node.HasClass("ttc"))
      {
        return string.Empty;
      }

      return doChildren(node);
    }
    else if (node.Name == "code")
    {
      var innerText = node.InnerText.FixNewlines().Replace(",", "");
      if (IsIdentifierPartOfAPI(innerText, api))
      {
        var cref = getCref(innerText);
        return $"<see cref=\"{cref}\" />";
      }

      return $"<c>{innerText}</c>";
    }

    return doChildren(node);
  }

  private bool IsIdentifierPartOfAPI(string identifier, ParsedAPI api)
  {
    return api.Functions.Any(f => f.Name == identifier) ||
           api.Macros.Any(m => m.Name == identifier) ||
           api.TypeDefs.Any(t => t.Name == identifier);
  }

  public bool IsIdentifierDelegate(string identifier, ParsedAPI api)
  {
    return api.TypeDefs.Any(t => t.Name == identifier && t is DelegateTypeDef);
  }

  private string RemovePrefixFromCppType(string typeName)
  {
    return typeName.Replace("const ", "").Replace("unsigned ", "");
  }

  private string ConvertToCSharpType(CppType cppType, ParsedAPI api, bool addArrayBrackets = true, bool forceDelegatesToIntPtr = false, bool preferArrayOverPointer = false)
  {
    var typeNameWithoutPrefix = RemovePrefixFromCppType(cppType.Name);
    var typeNameWithoutAst = typeNameWithoutPrefix.Replace("*", "").Trim();
    var typeNameWithoutAstWithPrefix = cppType.Name.Replace("*", "").Trim();
    if (IsIdentifierPartOfAPI(typeNameWithoutAst, api))
    {
      if (forceDelegatesToIntPtr && IsIdentifierDelegate(typeNameWithoutAst, api))
      {
        return "IntPtr";
      }

      return $"{typeNameWithoutPrefix}";
    }

    if (cppType.IsPointer && preferArrayOverPointer && typeNameWithoutAst != "void")
      return $"{ConvertToCSharpType(new CppType { Name = typeNameWithoutAstWithPrefix }, api)}[]";
    else if (cppType.IsPointer && preferArrayOverPointer && typeNameWithoutAst == "void")
      return "IntPtr";
    else if (cppType.IsPointer && !preferArrayOverPointer)
      return "IntPtr";

    var typeName = cppType.Name switch
    {
      "void" => "void",
      "char" => "byte",
      "unsigned char" => "byte",
      "short" => "short",
      "unsigned short" => "ushort",
      "int" => "int",
      "unsigned int" => "uint",
      "long" => "long",
      "unsigned long" => "ulong",
      "uint8_t" => "byte",
      "uint16_t" => "ushort",
      "uint32_t" => "uint",
      "uint64_t" => "ulong",
      "int8_t" => "sbyte",
      "int16_t" => "short",
      "int32_t" => "int",
      "int64_t" => "long",
      "float" => "float",
      "double" => "double",
      "size_t" => "nint",
      "VkResult" => "int",
      "VkInstance" => "IntPtr",
      "VkPhysicalDevice" => "IntPtr",
      "VkAllocationCallbacks" => "IntPtr",
      "VkSurfaceKHR" => "IntPtr",
      "GLFWglproc" => "IntPtr",
      "GLFWvkproc" => "IntPtr",
      _ => cppType.Name
    };

    if (cppType.IsArray && addArrayBrackets)
      typeName = $"{typeName}[]";

    return typeName.Remove("const").Remove("unsigned").Trim();
  }
}